using Avalonia.Controls.Primitives;
using Avalonia.Media.Imaging;
using Avalonia.Threading;
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using DiffusionNexus.LoraSort.Service.Classes;
using DiffusionNexus.LoraSort.Service.Search;
using DiffusionNexus.LoraSort.Service.Services;
using DiffusionNexus.UI.Classes;
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.IO;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;

namespace DiffusionNexus.UI.ViewModels;

public partial class LoraHelperViewModel : ViewModelBase
{
    // This is the backing list of *all* cards
    private readonly List<LoraCard> _allCards = new();
    private readonly SearchIndex _searchIndex = new();
    private List<string>? _indexNames;
    private CancellationTokenSource _suggestCts = new();
    private CancellationTokenSource _filterCts = new();

    [ObservableProperty]
    private bool showSuggestions;

    public ObservableCollection<string> SuggestionTokens { get; } = new();

    public IDialogService DialogService { get; set; } = null!;

    [ObservableProperty]
    private bool isLoading;

    [ObservableProperty]
    private string? searchText;

    [ObservableProperty]
    private FolderItemViewModel? selectedFolder;

    public IRelayCommand ResetFiltersCommand { get; }

    // What the View actually binds to
    public ObservableCollection<LoraCard> Cards { get; } = new();
    public ObservableCollection<FolderItemViewModel> FolderItems { get; } = new();
    private readonly ISettingsService _settingsService;
    public LoraHelperViewModel() : this(new SettingsService())
    {
    }

    public LoraHelperViewModel(ISettingsService settingsService)
    {
        _settingsService = settingsService;
        ResetFiltersCommand = new RelayCommand(ResetFilters);
        _ = LoadAsync();
    }

    private async Task LoadAsync()
    {
        IsLoading = true;
        var settings = await _settingsService.LoadAsync();
        if (string.IsNullOrWhiteSpace(settings.LoraHelperFolderPath))
        {
            IsLoading = false;
            return;
        }

        var discovery = new ModelDiscoveryService();

        var rootNode = await Task.Run(() => discovery.BuildFolderTree(settings.LoraHelperFolderPath));
        rootNode.IsExpanded = true; // Expand the root folder by default
        await Dispatcher.UIThread.InvokeAsync(() =>
        {
            FolderItems.Clear();
            FolderItems.Add(ConvertFolder(rootNode));
        });

        var models = await Task.Run(() => discovery.CollectModels(settings.LoraHelperFolderPath));

        await Dispatcher.UIThread.InvokeAsync(() =>
        {
            _allCards.Clear();
            Cards.Clear();
        });

        foreach (var model in models)
        {
            var folder = model.AssociatedFilesInfo.FirstOrDefault()?.DirectoryName;
            var card = new LoraCard { Name = model.ModelName, Model = model, FolderPath = folder, Parent = this };
            _allCards.Add(card);
            Dispatcher.UIThread.Post(() => Cards.Add(card));
        }

        StartIndexing();

        await Dispatcher.UIThread.InvokeAsync(() => IsLoading = false);
    }

    private FolderItemViewModel ConvertFolder(FolderNode node)
    {
        var vm = new FolderItemViewModel
        {
            Name = node.Name,
            ModelCount = node.ModelCount,
            Path = node.FullPath,
            IsExpanded = node.IsExpanded
        };
        foreach (var child in node.Children)
            vm.Children.Add(ConvertFolder(child));
        return vm;
    }

    // 3) This partial method is generated by [ObservableProperty];
    //    it runs whenever SearchText is set.
    partial void OnSearchTextChanged(string? value)
    {
        _ = RefreshCardsAsync();
        DebounceSuggestions();
    }

    partial void OnSelectedFolderChanged(FolderItemViewModel? value)
    {
        if (value != null)
            SearchText = null;
        _ = RefreshCardsAsync();
    }

    private async Task RefreshCardsAsync()
    {
        _filterCts.Cancel();
        _filterCts = new CancellationTokenSource();
        var token = _filterCts.Token;

        var search = SearchText;
        var folder = SelectedFolder;

        IsLoading = true;

        var list = await Task.Run(() => FilterCards(search, folder), token);
        if (token.IsCancellationRequested)
            return;

        await Dispatcher.UIThread.InvokeAsync(() =>
        {
            Cards.Clear();
            foreach (var c in list)
                Cards.Add(c);
            IsLoading = false;
        });
    }

    private List<LoraCard> FilterCards(string? search, FolderItemViewModel? folder)
    {
        IEnumerable<LoraCard> query = _allCards;

        if (folder != null)
            query = query.Where(c =>
                c.FolderPath != null && c.FolderPath.StartsWith(folder.Path!, StringComparison.OrdinalIgnoreCase));

        if (!string.IsNullOrWhiteSpace(search))
        {
            if (_searchIndex.IsReady && _indexNames != null)
            {
                var matches = _searchIndex.Search(search!)
                    .Select(i => _allCards[i])
                    .ToHashSet();
                if (matches.Count > 0)
                    query = query.Where(c => matches.Contains(c));
                else
                    query = query.Where(c =>
                        c.Name?.Contains(search!, StringComparison.OrdinalIgnoreCase) == true);
            }
            else
            {
                query = query.Where(c =>
                    c.Name?.Contains(search!, StringComparison.OrdinalIgnoreCase) == true);
            }
        }

        return query.ToList();
    }

    private void ResetFilters()
    {
        SelectedFolder = null;
        SearchText = null;
        _ = RefreshCardsAsync();
    }

    /// <summary>
    /// Kick off background construction of the search index. This does not block
    /// the UI and existing filtering logic is used until indexing completes.
    /// </summary>
    private void StartIndexing()
    {
        _indexNames = _allCards.Select(c => c.Name ?? string.Empty).ToList();
        var namesCopy = _indexNames.ToList();
        Task.Run(() => _searchIndex.Build(namesCopy));
    }

    /// <summary>
    /// Trigger suggestion updates with a 200ms debounce to avoid UI jank while
    /// the user types.
    /// </summary>
    private void DebounceSuggestions()
    {
        _suggestCts.Cancel();
        _suggestCts = new CancellationTokenSource();
        var token = _suggestCts.Token;
        Task.Run(async () =>
        {
            try
            {
                await Task.Delay(200, token);
                await Dispatcher.UIThread.InvokeAsync(UpdateSuggestions);
            }
            catch (TaskCanceledException) { }
        }, token);
    }

    /// <summary>
    /// Refresh the autocomplete suggestion list using the search index.
    /// </summary>
    private void UpdateSuggestions()
    {
        if (!_searchIndex.IsReady || string.IsNullOrWhiteSpace(SearchText))
        {
            SuggestionTokens.Clear();
            ShowSuggestions = false;
            return;
        }

        var list = _searchIndex.Suggest(SearchText!, 10).ToList();
        SuggestionTokens.Clear();
        foreach (var s in list)
            SuggestionTokens.Add(s);
        ShowSuggestions = list.Count > 0;
    }

    /// <summary>
    /// Called from the view when a suggestion is chosen by the user.
    /// </summary>
    public void ApplySuggestion(string suggestion)
    {
        SearchText = suggestion;
        ShowSuggestions = false;
    }

    public async Task DeleteCardAsync(LoraCard card)
    {
        if (DialogService == null || card.Model == null)
            return;

        var confirm = await DialogService.ShowConfirmationAsync($"Delete '{card.Name}'?");
        if (confirm != true) return;

        foreach (var file in card.Model.AssociatedFilesInfo)
        {
            try { File.Delete(file.FullName); } catch { }
        }

        _allCards.Remove(card);
        Cards.Remove(card);
        StartIndexing();
    }
}


public partial class LoraCard : ViewModelBase
{
    [ObservableProperty]
    private string? _name;

    [ObservableProperty]
    private string? _description;

    [ObservableProperty]
    private ModelClass? _model;

    [ObservableProperty]
    private Bitmap? _previewImage;

    [ObservableProperty]
    private string? folderPath;

    public IRelayCommand EditCommand { get; }
    public IAsyncRelayCommand DeleteCommand { get; }
    public IRelayCommand OpenWebCommand { get; }
    public IRelayCommand CopyCommand { get; }

    public LoraHelperViewModel? Parent { get; set; }

    public LoraCard()
    {
        EditCommand = new RelayCommand(OnEdit);
        DeleteCommand = new AsyncRelayCommand(OnDeleteAsync);
        OpenWebCommand = new RelayCommand(OnOpenWeb);
        CopyCommand = new RelayCommand(OnCopy);
    }

    partial void OnModelChanged(ModelClass? value)
    {
        _ = LoadPreviewImageAsync();
    }

    private async Task LoadPreviewImageAsync()
    {
        var path = GetPreviewImagePath();
        if (path is null || !File.Exists(path))
        {
            PreviewImage = null;
            return;
        }

        try
        {
            var bitmap = await Task.Run(() =>
            {
                using var stream = File.OpenRead(path);
                return new Bitmap(stream);
            });
            await Dispatcher.UIThread.InvokeAsync(() => PreviewImage = bitmap);
        }
        catch
        {
            await Dispatcher.UIThread.InvokeAsync(() => PreviewImage = null);
        }
    }

    public string? GetPreviewImagePath()
    {
        if (Model == null) return null;
        string[] priority = [
            ".thumb.jpg",
            ".webp",
            "jpeg",
            "jpg",
            ".preview.webp",
            ".preview.jpeg",
            ".preview.jpg",
        ];

        foreach (var ext in priority)
        {
            var file = Model.AssociatedFilesInfo.FirstOrDefault(f => f.Name.EndsWith(ext, StringComparison.OrdinalIgnoreCase));
            if (file != null)
                return file.FullName;
        }
        return null;
    }

    private void OnEdit() => Log($"Edit {Name}");

    private Task OnDeleteAsync()
    {
        return Parent?.DeleteCardAsync(this) ?? Task.CompletedTask;
    }

    private void OnOpenWeb() => Log($"Open web for {Name}");

    private void OnCopy() => Log($"Copy {Name}");
}
